{"cyber-dojo.sh":"rm -f *.class\nCLASSES=.:`ls /junit/*.jar | tr '\\n' ':'`\njavac -Xlint:unchecked -Xlint:deprecation -cp $CLASSES  *.java\n\nif [ $? -eq 0 ]; then\n  # run test classes even if they are inner classes\n  # remove voluminous stack trace from output\n  java -cp $CLASSES org.junit.runner.JUnitCore `ls -1 *Test*.class | grep -v '\\\\$' | sed 's/\\(.*\\)\\..*/\\1/'` | grep -Ev 'org.junit.runner|org.junit.internal|sun.reflect|org.junit.Assert|java.lang.reflect|org.hamcrest'\nfi\n\n","output":"JUnit version 4.11-SNAPSHOT-20120416-1530\n.\nTime: 0.032\n\nOK (1 test)\n\n","instructions":"Java Functional Programming by Jessica Kerr\n\noriginal\n\nfunctional programming with java\n  C24C65, tuna, fpwj-original\n  4DAE5E, starfish, fpwj-functionsAsValues\n  BDA089, snake, fpwj-functionsReturningFunctions\n  D96026, salmon, fpwj-typeSafe","FixedCosts.java":"\npublic class FixedCosts extends PolynomialQuantity {\n\n    public FixedCosts(double constant) {\n        super(new double[] {constant} );\n    }\n\n    @Override\n    public String getName() {\n        return \"Fixed Costs\";\n    }\n}\n","IncrementalCosts.java":"public class IncrementalCosts extends PolynomialQuantity {\n\n    public IncrementalCosts(final double intercept,\n                            final double slope) {\n        super(new double[] { intercept, slope });\n    }\n\n    @Override\n    public String getName() {\n        return \"Incremental Costs\";\n    }\n}\n","MonthByMonthQuantity.java":"\nabstract class MonthByMonthQuantity implements QuantityOfInterest {\n\n    private final double[] values;\n\n    protected MonthByMonthQuantity(final double[] values) {\n        this.values = values;\n    }\n\n    @Override\n    public double valueAt(final int time) {\n        return values[time - 1];\n    }\n}\n","PolynomialQuantity.java":"\n\nabstract class PolynomialQuantity implements QuantityOfInterest {\n\n    private final double[] coefficients;\n\n    protected PolynomialQuantity(final double[] coefficients) {\n        this.coefficients = coefficients;\n    }\n\n    @Override\n    public double valueAt(final int time) {\n        double value = 0.0;\n        for(int i = 0; i < coefficients.length; i++) {\n            value += coefficients[i] * Math.pow(time, i);\n        }\n        return value;\n    }\n}\n","Profit.java":"\n\npublic class Profit implements QuantityOfInterest {\n\n    private final Sales sales;\n    private final IncrementalCosts incrementalCosts;\n    private final FixedCosts fixedCosts;\n\n    public Profit(final Sales sales,\n                  final IncrementalCosts incrementalCosts,\n                  final FixedCosts fixedCosts) {\n        this.sales = sales;\n        this.incrementalCosts = incrementalCosts;\n        this.fixedCosts = fixedCosts;\n    }\n\n    @Override\n    public String getName() {\n        return \"Profit!!\";\n    }\n\n    @Override\n    public double valueAt(final int time) {\n        return sales.valueAt(time) -\n                (incrementalCosts.valueAt(time) +\n                 fixedCosts.valueAt(time));\n    }\n}\n","QuantityOfInterest.java":"\n\npublic interface QuantityOfInterest {\n\n    String getName();\n\n    /**\n     * expected value for a particular month\n     * @param time month, 1-12\n     * @return expected value\n     */\n    double valueAt(final int time);\n}","Sales.java":"\npublic class Sales extends MonthByMonthQuantity {\n\n    public Sales(final double[] values) {\n        super(values);\n    }\n\n    @Override\n    public String getName() {\n        return \"Expected Sales\";\n    }\n}\n","ProfitTest.java":"import org.junit.*;\nimport static org.junit.Assert.*;\n\npublic class ProfitTest {\n    @Test\n    public void should_calculate_total_profits_for_the_year() {\n        // given\n        final double[] EXPECTED_SALES_JAN_TO_DEC =\n            new double[] { 42.0, 45.6, 43.6, 50.2, 55.6, 54.7,\n                    58.0, 57.3, 62.0, 60.3, 71.2, 88.8};\n        final Sales sales = new Sales(EXPECTED_SALES_JAN_TO_DEC);\n\n        final FixedCosts fixedCosts = new FixedCosts(15.0);\n        final IncrementalCosts incrementalCosts =\n                new IncrementalCosts(5.1, 0.15);\n\n        final Profit profit = new Profit(\n                sales,\n                incrementalCosts,\n                fixedCosts\n        );\n\n        // when\n        double totalProfits = 0.0;\n        for(int i = 1; i <= 12; i++) {\n            totalProfits += profit.valueAt(i);\n        }\n\n        // then\n        assertEquals(436.4, totalProfits, 0.001);\n    }\n}"}